use crate::{asset::AssetRef, config};
use anyhow::bail;
use relative_path::{RelativePath, RelativePathBuf};
use std::{collections::BTreeMap, path::Path};

pub enum Node {
    Table(BTreeMap<String, Node>),
    String(String),
    Content(String),
    #[allow(dead_code)]
    Number(u64),
}

pub enum Language {
    TypeScript,
    Luau,
}

pub type NodeSource = BTreeMap<RelativePathBuf, AssetRef>;

pub fn create_node(source: &NodeSource, config: &config::Codegen) -> Node {
    let mut root = Node::Table(BTreeMap::new());

    for (path, value) in source {
        let value = if config.content {
            Node::Content(value.to_string())
        } else {
            Node::String(value.to_string())
        };

        match config.style {
            config::CodegenStyle::Nested => {
                let components = normalize_path_components(path, config.strip_extensions);
                insert_nested(&mut root, &components, value);
            }
            config::CodegenStyle::Flat => {
                let key = normalize_path_string(path, config.strip_extensions);
                insert_flat(&mut root, &key, value);
            }
        }
    }

    root
}

fn normalize_path_components(path: &RelativePath, strip_extensions: bool) -> Vec<String> {
    let mut components: Vec<String> = Vec::new();
    let total_components = path.iter().count();

    for (i, comp) in path.iter().enumerate() {
        if i == total_components - 1 && strip_extensions {
            let as_path = Path::new(comp);
            if let Some(stem) = as_path.file_stem() {
                components.push(stem.to_string_lossy().to_string());
                continue;
            }
        }
        components.push(comp.to_string());
    }
    components
}

fn normalize_path_string(path: &RelativePath, strip_extensions: bool) -> String {
    if strip_extensions
        && let (Some(file_name), Some(parent)) = (path.file_name(), path.parent())
        && let Some(stem) = Path::new(file_name).file_stem()
    {
        let parent_str = parent.to_string();
        return if parent_str.is_empty() || parent_str == "." {
            stem.to_string_lossy().to_string()
        } else {
            format!("{}/{}", parent_str, stem.to_string_lossy())
        };
    }
    path.to_string()
}

fn insert_flat(node: &mut Node, key: &str, value: Node) {
    match node {
        Node::Table(map) => {
            map.insert(key.into(), value);
        }
        _ => {
            *node = Node::Table(BTreeMap::new());
            if let Node::Table(map) = node {
                map.insert(key.into(), value);
            }
        }
    }
}

fn insert_nested(node: &mut Node, components: &[String], value: Node) {
    if !matches!(node, Node::Table(_)) {
        *node = Node::Table(BTreeMap::new());
    }

    if components.is_empty() {
        return;
    }

    if let Node::Table(map) = node {
        let component = &components[0];

        if components.len() == 1 {
            map.insert(component.clone(), value);
        } else {
            let next_node = map
                .entry(component.clone())
                .or_insert_with(|| Node::Table(BTreeMap::new()));

            if !matches!(next_node, Node::Table(_)) {
                *next_node = Node::Table(BTreeMap::new());
            }

            insert_nested(next_node, &components[1..], value);
        }
    }
}

pub fn generate_code(lang: Language, name: &str, node: &Node) -> anyhow::Result<String> {
    if !matches!(node, Node::Table(_)) {
        bail!("Root node must be a Table");
    }

    Ok(match lang {
        Language::TypeScript => generate_typescript(name, node),
        Language::Luau => generate_luau(name, node),
    })
}

fn generate_typescript(name: &str, node: &Node) -> String {
    let body = generate_ts_node(node, 0);
    format!(
        "// This file is automatically @generated by Asphalt.\n// It is not intended for manual editing.\ndeclare const {name}: {body}\n\nexport = {name}"
    )
}

fn generate_ts_node(node: &Node, indent: usize) -> String {
    match node {
        Node::Table(map) => {
            let mut result = String::from("{\n");
            for (k, v) in map {
                result.push_str(&"\t".repeat(indent + 1));
                let k = if is_valid_identifier(k) {
                    k.clone()
                } else {
                    format!("\"{k}\"")
                };
                result.push_str(&k);
                result.push_str(": ");
                result.push_str(&generate_ts_node(v, indent + 1));
                result.push('\n');
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
        Node::String(_) => "string".to_string(),
        Node::Content(_) => "Content".to_string(),
        Node::Number(_) => "number".to_string(),
    }
}

fn generate_luau(name: &str, node: &Node) -> String {
    let body = generate_luau_node(node, 0);
    format!(
        "-- This file is automatically @generated by Asphalt.\n-- It is not intended for manual editing.\nlocal {name} = {body}\n\nreturn {name}"
    )
}

fn generate_luau_node(node: &Node, indent: usize) -> String {
    match node {
        Node::Table(map) => {
            let mut result = String::from("{\n");
            for (k, v) in map {
                result.push_str(&"\t".repeat(indent + 1));
                let k = if is_valid_identifier(k) {
                    k.clone()
                } else {
                    format!("[\"{k}\"]")
                };
                result.push_str(&k);
                result.push_str(" = ");
                result.push_str(&generate_luau_node(v, indent + 1));
                result.push_str(",\n");
            }
            result.push_str(&"\t".repeat(indent));
            result.push('}');
            result
        }
        Node::String(s) => format!("\"{s}\""),
        Node::Content(s) => format!("Content.fromUri(\"{s}\")"),
        Node::Number(n) => format!("{n}"),
    }
}

fn is_valid_ident_char_start(value: char) -> bool {
    value.is_ascii_alphabetic() || value == '_'
}

fn is_valid_ident_char(value: char) -> bool {
    value.is_ascii_alphanumeric() || value == '_'
}

fn is_valid_identifier(value: &str) -> bool {
    let mut chars = value.chars();

    match chars.next() {
        Some(first) => {
            if !is_valid_ident_char_start(first) {
                return false;
            }
        }
        None => return false,
    }

    chars.all(is_valid_ident_char)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_test_node() -> Node {
        let mut inner_map = BTreeMap::new();
        inner_map.insert("foo".to_string(), Node::String("bar".to_string()));
        inner_map.insert("baz".to_string(), Node::Number(42));
        let inner_node = Node::Table(inner_map);

        let mut root_inner = BTreeMap::new();
        root_inner.insert("qux".to_string(), inner_node);
        root_inner.insert("fred".to_string(), Node::String("world".to_string()));
        root_inner.insert("waldo".to_string(), Node::Content("garply".to_string()));

        Node::Table(root_inner)
    }

    #[test]
    fn test_typescript_codegen() {
        let root_node = make_test_node();
        let code = generate_code(Language::TypeScript, "name", &root_node).unwrap();
        insta::assert_snapshot!(code);
    }

    #[test]
    fn test_luau_codegen() {
        let root_node = make_test_node();
        let code = generate_code(Language::Luau, "name", &root_node).unwrap();
        insta::assert_snapshot!(code);
    }
}
